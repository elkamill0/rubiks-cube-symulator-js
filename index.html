<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Rubik Cube Solver</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="container mt-3">
  <h2>Rubik Cube Solver</h2>

  <div class="d-flex flex-column flex-md-row gap-3">
    <!-- Lewa kolumna: kostka + kontrolki -->
    <div class="flex-fill">
      <div class="card p-3 mb-3">
        <div id="cubeView" class="mb-3"></div>

        <div class="mb-2">
          <label for="movesInput" class="form-label">Scramble / Moves</label>
          <input type="text" id="movesInput" class="form-control"
                 value="B L B2 U' L' B L' R2 D' L B F2 L' B2 L U2 L F' U' R2 D2">
        </div>

        <div class="d-flex gap-2 mb-2 flex-wrap">
          <button id="applyMoves" class="btn btn-primary flex-fill">Apply Moves</button>
          <button id="resetCube" class="btn btn-secondary flex-fill">Reset Cube</button>
        </div>

        <div class="mb-2">
          <label for="crossColor" class="form-label">Cross color</label>
          <select id="crossColor" class="form-select">
            <option value="w">White</option>
            <option value="r">Red</option>
            <option value="b">Blue</option>
            <option value="g">Green</option>
            <option value="o">Orange</option>
            <option value="y">Yellow</option>
          </select>
        </div>

        <div class="mb-2">
          <label for="crossLength" class="form-label">Max cross length</label>
          <input type="number" id="crossLength" class="form-control" min="1" max="8" value="4">
        </div>

        <div class="d-flex gap-2 mb-2 flex-wrap">
          <button id="findCross" class="btn btn-success flex-fill">Find Cross</button>
          <button id="buildTreeButton" class="btn btn-warning flex-fill">Build Reconstruction</button>
        </div>
      </div>
    </div>

    <!-- Prawa kolumna: lista rekonstrukcji -->
    <div class="flex-fill">
      <div class="card p-3 h-100">
        <h3>Reconstruction</h3>
        <div id="reconstructionOutput" class="d-grid gap-2 solution-container"></div>
      </div>
    </div>
  </div>
</div>



<!-- ===== IMPORTY SKRYPTÓW (KOLEJNOŚĆ MA ZNACZENIE) ===== -->
<script src="moves/moves_corners.js"></script>
<script src="moves/moves_edges.js"></script>
<script src="moves/moves_centers.js"></script>
<script src="moves/moves.js"></script>
<script src="scramble.js"></script>
<script src="tools.js"></script>
<script src="convert.js"></script>
<script src="solver.js"></script>
<script src="cross.js"></script>
<script src="f2l.js"></script>
<script src="oll.js"></script>
<script src="pll.js"></script>
<script src="cube.js"></script>
<script src="solving_stage.js"></script>

<script>
let cube = new Cube();

const cubeView = document.getElementById("cubeView");

function renderCube() {
  cubeView.textContent = cube.toString();
}

// wykonaj ruchy
document.getElementById("applyMoves").addEventListener("click", () => {
  let notation = document.getElementById("movesInput").value.trim();
  if (!notation) notation = scramble.generateScramble(21); // tutaj ma być długość pobierana z pola length
    cube = new Cube({
    color: document.getElementById("crossColor").value,
    notation: notation
  });
  // na stronie html ma być wypisane jakie ruchy zostały wykorzystane
  
  renderCube();
});

// reset kostki
document.getElementById("resetCube").addEventListener("click", () => {
  cube.reset();
  renderCube();
});

const reconstructionOutput = document.getElementById("reconstructionOutput");

function renderNode(node, depth = 0, isRoot = false) {
    const details = document.createElement("details");
    details.open = false;
    details.style.marginLeft = `${depth * 20}px`;

    if (isRoot) {
        details.classList.add("cross-root");
    }

    const summary = document.createElement("summary");
    summary.textContent =
        node.name + (node.alg ? " " + node.alg : "");

    details.appendChild(summary);

    if (node.child && node.child.length > 0) {
        for (const child of node.child) {
            details.appendChild(renderNode(child, depth + 1));
        }
    }

    return details;
}

function renderSolutions(nodes, container) {
    container.innerHTML = "";

    for (const node of nodes) {
        const btn = document.createElement("button");
        btn.textContent = `${node.name} ${node.alg || ""}`;
        btn.style.display = "block";
        btn.style.marginBottom = "6px";

        btn.addEventListener("click", () => {
            cube.corners = node.cube.corners.map(c => [...c]);
            cube.edges = node.cube.edges.map(e => [...e]);
            cube.centers = [...node.cube.centers];

            renderCube();

            if (node.child && node.child.length > 0) {
                renderSolutions(node.child, container);
            }
        });

        container.appendChild(btn);
    }
}


function enableCrossAccordion(container) {
    container.addEventListener("toggle", (e) => {
        const target = e.target;

        if (!target.classList.contains("cross-root")) return;
        if (!target.open) return;

        const allCrosses = container.querySelectorAll(".cross-root");
        for (const cross of allCrosses) {
            if (cross !== target) {
                cross.open = false;
            }
        }
    });
}


// const buildTreeButton = document.createElement("button");


// buildTreeButton.textContent = "Build Tree";
// document.body.insertBefore(buildTreeButton, reconstructionOutput);

const buildTreeButton = document.getElementById("buildTreeButton");


buildTreeButton.addEventListener("click", async () => {
    reconstructionOutput.textContent = "Budowanie drzewa...";
    const lengthInput = document.getElementById("crossLength");
    let length = parseInt(lengthInput.value, 10);

    try {
        const solving = new Solving(cube);
        const rootNodes = await solving.build_tree(length);

        reconstructionOutput.textContent = "";

        for (const node of rootNodes) {
            reconstructionOutput.appendChild(
                renderNode(node, 0, true)
            );
        }

        enableCrossAccordion(reconstructionOutput);

    } catch (err) {
        console.error(err);
        reconstructionOutput.textContent = "Błąd podczas budowy drzewa.";
    }
});

buildTreeButton.addEventListener("click", async () => {
    reconstructionOutput.textContent = "Budowanie drzewa...";
    const lengthInput = document.getElementById("crossLength");
    let length = parseInt(lengthInput.value, 10);

    try {
        const solving = new Solving(cube);
        const rootNodes = await solving.build_tree(length);

        reconstructionOutput.innerHTML = "";
        renderSolutions(rootNodes, reconstructionOutput);

    } catch (err) {
        console.error(err);
        reconstructionOutput.textContent = "Błąd podczas budowy drzewa.";
    }
});


renderCube();
</script>

</body>
</html>
